[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Professional Précis",
    "section": "",
    "text": "The difference between software engineering and programming is really professionalism and consistency ultimetly software engineering can be defined as programming integrated overtime. What can someone do to make a code sustainable and improve upon in the future what are some tools that can be used to make something more efficient all of this is software engineering. There are three things to take into account according to The section Programming Overtime in the book Software Engineering at Google.\n\nHow the code will need to be changed over its life time\nHow you will have to adapt as things change and evolve\nTake into account Time change Scale and growth when making a decision.\n\nI belive this way of thinking is not only beneficial to Chasten but almost any software engineering project in general because at the end of the day all its saying is expect things to change. And how you need to make decisions which means you may not be able to do everthing you wanted to which I feel should be somewhat expected alot of the time."
  },
  {
    "objectID": "index.html#se1-programming-overtime",
    "href": "index.html#se1-programming-overtime",
    "title": "Professional Précis",
    "section": "",
    "text": "The difference between software engineering and programming is really professionalism and consistency ultimetly software engineering can be defined as programming integrated overtime. What can someone do to make a code sustainable and improve upon in the future what are some tools that can be used to make something more efficient all of this is software engineering. There are three things to take into account according to The section Programming Overtime in the book Software Engineering at Google.\n\nHow the code will need to be changed over its life time\nHow you will have to adapt as things change and evolve\nTake into account Time change Scale and growth when making a decision.\n\nI belive this way of thinking is not only beneficial to Chasten but almost any software engineering project in general because at the end of the day all its saying is expect things to change. And how you need to make decisions which means you may not be able to do everthing you wanted to which I feel should be somewhat expected alot of the time."
  },
  {
    "objectID": "index.html#fb1-introduction-to-software-testing",
    "href": "index.html#fb1-introduction-to-software-testing",
    "title": "Professional Précis",
    "section": "FB1 Introduction to Software Testing",
    "text": "FB1 Introduction to Software Testing\nIt is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  }
]