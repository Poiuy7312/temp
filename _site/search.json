[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Professional Précis SE Book",
    "section": "",
    "text": "The difference between software engineering and programming is really professionalism and consistency ultimetly software engineering can be defined as programming integrated overtime. What can someone do to make a code sustainable and improve upon in the future what are some tools that can be used to make something more efficient all of this is software engineering. There are three things to take into account according to The section Programming Overtime in the book Software Engineering at Google.\n\nHow the code will need to be changed over its life time\nHow you will have to adapt as things change and evolve\nTake into account Time change Scale and growth when making a decision.\n\n\n\nI belive this way of thinking is not only beneficial to Chasten but almost any software engineering project in general because at the end of the day all its saying is expect things to change. And how you need to make decisions which means you may not be able to do everthing you wanted to which I feel should be somewhat expected alot of the time."
  },
  {
    "objectID": "index.html#se1-programming-overtime",
    "href": "index.html#se1-programming-overtime",
    "title": "Professional Précis SE Book",
    "section": "",
    "text": "The difference between software engineering and programming is really professionalism and consistency ultimetly software engineering can be defined as programming integrated overtime. What can someone do to make a code sustainable and improve upon in the future what are some tools that can be used to make something more efficient all of this is software engineering. There are three things to take into account according to The section Programming Overtime in the book Software Engineering at Google.\n\nHow the code will need to be changed over its life time\nHow you will have to adapt as things change and evolve\nTake into account Time change Scale and growth when making a decision.\n\n\n\nI belive this way of thinking is not only beneficial to Chasten but almost any software engineering project in general because at the end of the day all its saying is expect things to change. And how you need to make decisions which means you may not be able to do everthing you wanted to which I feel should be somewhat expected alot of the time."
  },
  {
    "objectID": "index.html#fb1-introduction-to-software-testing",
    "href": "index.html#fb1-introduction-to-software-testing",
    "title": "Professional Précis SE Book",
    "section": "FB1 Introduction to Software Testing",
    "text": "FB1 Introduction to Software Testing\nIt is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  },
  {
    "objectID": "index.html#se2-what-is-software-engineering",
    "href": "index.html#se2-what-is-software-engineering",
    "title": "Professional Précis SE Book",
    "section": "SE2 What is Software Engineering?",
    "text": "SE2 What is Software Engineering?\nOnce again Software Engineering is defined as programming overtime but this time in more detail. While a programming project might be a single person endeavor a software engineering project is a team effort. Teamwork is very important for these types of projects as while working as a team can have it owns issues the amount you can do with more people is much greater. You have to take into account problems and changes to the software appearing as its being made and when its already released. You need to make trade offs between how much money or time something is gonna cost and how much benefit it will have for the software. A software engineering project is expected to last for years and with that needs to be amiable to changes as maybe the dependencies it uses change the OS changes and also competition at least at a large scale that might arise as to not be overshadowed by superior software.\n\nUse-Case\nThis way of thinking while I don’t think entirely applicable to chasten I think the importance of working together and take into account how things change is very important especially since overall we seem to be having problems working together and being organized. This has lead to things not being done on time multiple people being confused on what they should do and what they are doing. So I think communication with each other is very important for chasten and software in general and after that comes the more complicated questions on how chasten may change overtime how long do we want it to last and how amicable it is are second to teamwork."
  },
  {
    "objectID": "SE.html",
    "href": "SE.html",
    "title": "Professional Précis Fuzzing Book",
    "section": "",
    "text": "It is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  },
  {
    "objectID": "SE.html#fb1-introduction-to-software-testing",
    "href": "SE.html#fb1-introduction-to-software-testing",
    "title": "Professional Précis Fuzzing Book",
    "section": "",
    "text": "It is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  }
]