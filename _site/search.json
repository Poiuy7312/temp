[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Professional Précis SE Book",
    "section": "",
    "text": "The difference between software engineering and programming is professionalism and consistency ultimately software engineering can be defined as programming integrated over time. What can someone do to make a code sustainable and improve upon in the future what are some tools that can be used to make something more efficient all of this is software engineering. There are three things to take into account according to The section Programming Overtime in the book Software Engineering at Google.\n\nHow the code will need to be changed over its lifetime\nHow you will have to adapt as things change and evolve\nTake into account Time change Scale and growth when making a decision.\n\n\n\nI believe this way of thinking is not only beneficial to Chasten but almost any software engineering project in general because, at the end of the day, all it’s saying is to expect things to change. And how you need to make decisions which means you may not be able to do everything you wanted to which I feel should be somewhat expected a lot of the time."
  },
  {
    "objectID": "index.html#se1-programming-overtime",
    "href": "index.html#se1-programming-overtime",
    "title": "Professional Précis SE Book",
    "section": "",
    "text": "The difference between software engineering and programming is professionalism and consistency ultimately software engineering can be defined as programming integrated over time. What can someone do to make a code sustainable and improve upon in the future what are some tools that can be used to make something more efficient all of this is software engineering. There are three things to take into account according to The section Programming Overtime in the book Software Engineering at Google.\n\nHow the code will need to be changed over its lifetime\nHow you will have to adapt as things change and evolve\nTake into account Time change Scale and growth when making a decision.\n\n\n\nI believe this way of thinking is not only beneficial to Chasten but almost any software engineering project in general because, at the end of the day, all it’s saying is to expect things to change. And how you need to make decisions which means you may not be able to do everything you wanted to which I feel should be somewhat expected a lot of the time."
  },
  {
    "objectID": "index.html#fb1-introduction-to-software-testing",
    "href": "index.html#fb1-introduction-to-software-testing",
    "title": "Professional Précis SE Book",
    "section": "FB1 Introduction to Software Testing",
    "text": "FB1 Introduction to Software Testing\nIt is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  },
  {
    "objectID": "index.html#se2-what-is-software-engineering",
    "href": "index.html#se2-what-is-software-engineering",
    "title": "Professional Précis SE Book",
    "section": "SE2 What is Software Engineering?",
    "text": "SE2 What is Software Engineering?\nOnce again Software Engineering is defined as programming over time but this time in more detail. While a programming project might be a single-person endeavor a software engineering project is a team effort. Teamwork is very important for these types of projects as while working as a team can have its issues the amount you can do with more people is much greater. You have to take into account problems and changes to the software appearing as it is being made and when it is already released. You need to make trade-offs between how much money or time something is gonna cost and how much benefit it will have for the software. A software engineering project is expected to last for years and with that needs to be amiable to changes as maybe the dependencies it uses to change the OS changes and also competition at least at a large scale that might arise to not be overshadowed by superior software.\n\nUse-Case\nThis way of thinking while I don’t think entirely applicable to chasten I think the importance of working together and taking into account how things change is very important especially since overall we seem to be having problems working together and being organized. This has led to things not being done on time and multiple people being confused about what they should do and what they are doing. So I think communication with each other is very important for chasten and software in general and after that comes the more complicated questions on how chasten may change over time how long we want it to last and how amicable it is are second to teamwork."
  },
  {
    "objectID": "SE.html",
    "href": "SE.html",
    "title": "Professional Précis Fuzzing Book",
    "section": "",
    "text": "It is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\n\n\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  },
  {
    "objectID": "SE.html#fb1-introduction-to-software-testing",
    "href": "SE.html#fb1-introduction-to-software-testing",
    "title": "Professional Précis Fuzzing Book",
    "section": "",
    "text": "It is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t really need a test case for different types of numbers. You should also check for invalid inputs so if someone trys to put a string into something that calculates squares thats obviously not going to work so your code should account for that in someway. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\n\n\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished proffesional and easier to use for anyone trying to."
  },
  {
    "objectID": "SE.html#fb2",
    "href": "SE.html#fb2",
    "title": "Professional Précis Fuzzing Book",
    "section": "FB2",
    "text": "FB2\nCode Coverage is very important when writing test cases because you want to strive for as much of your code being tested as possible. So being able to check the effectiveness and coverage is crucial when writing good test cases. An example on how you can test this is in the Fuzzing Book where there is a library with functions like .trace() and .coverage() which list what lines are in a given function and one returns what lines of code are atleast run once. and using these librarys there was code that prints out code with the run lines marked by a # symbol\n\nUse-case\nThis can be very useful when working on chasten to test if your the test cases being written and already there are doing there job properly. One of the last things you want is for you test your code think it works but a significant portion of it not being tested and maybe their is some major bug that is missed as a result. This is even more important when making software other people are going to use because then alot more things can go wrong because the code may need to adapt to different computers causing more issues that could be missed by testing."
  },
  {
    "objectID": "SE.html#fb2-code-coverage",
    "href": "SE.html#fb2-code-coverage",
    "title": "Professional Précis Fuzzing Book",
    "section": "FB2 Code Coverage",
    "text": "FB2 Code Coverage\nCode Coverage is very important when writing test cases because you want to strive for as much of your code being tested as possible. So being able to check the effectiveness and coverage is crucial when writing good test cases. An example on how you can test this is in the Fuzzing Book where there is a library with functions like .trace() and .coverage() which list what lines are in a given function and one returns what lines of code are atleast run once. and using these librarys there was code that prints out code with the run lines marked by a # symbol\n\nUse-case\nThis can be very useful when working on chasten to test if your the test cases being written and already there are doing there job properly. One of the last things you want is for you test your code think it works but a significant portion of it not being tested and maybe their is some major bug that is missed as a result. This is even more important when making software other people are going to use because then alot more things can go wrong because the code may need to adapt to different computers causing more issues that could be missed by testing."
  },
  {
    "objectID": "index.html#se3-how-to-work-well-on-teams",
    "href": "index.html#se3-how-to-work-well-on-teams",
    "title": "Professional Précis SE Book",
    "section": "SE3 How to Work Well on Teams",
    "text": "SE3 How to Work Well on Teams\nTeamwork is an important aspect of Software Engineering almost every major accomplishment in Software Engineering was accomplished by groups of people, not one person by themselves. While Linus Torvalds created the framework for Linux the vast majority of its current form was made by other people there is not just one person who’s good at everything many people are required to make something truly great even if you might consider someone a genius. It doesn’t require a genius to make something important just a team of individuals who communicate, cooperate and criticize to get the best possible product or result. Michael Jordan didn’t win six championships as an individual he one them as a part of the Chicago Bulls basketball team.\n\nUse-Case\nThis is very important to keep in mind two minds are better than one you aren’t going to be able to do everything on your own. For chasten, while it’s not the largest project it is certainly not something we can achieve as individuals almost everything we do can affect someone else’s work making it important that we communicate what we are doing and why we are doing it. Things get done faster and often better when working together."
  },
  {
    "objectID": "FB.html",
    "href": "FB.html",
    "title": "Professional Précis Fuzzing Book",
    "section": "",
    "text": "It is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test-case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case of the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t need a test case for different types of numbers. You should also check for invalid inputs so if someone tries to put a string into something that calculates squares that’s not going to work so your code should account for that in some way. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\n\n\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished and professional and easier to use for anyone trying to."
  },
  {
    "objectID": "FB.html#fb1-introduction-to-software-testing",
    "href": "FB.html#fb1-introduction-to-software-testing",
    "title": "Professional Précis Fuzzing Book",
    "section": "",
    "text": "It is important to test your code and be able to understand it. You can test your code by putting in inputs you know the expected outcome for and compare or you can write a test-case for it which will automatically test and compare the actual output and the set expected output for you. In some cases you can even in a way generate a test case of the Fuzzingbook has a really good example of this.\ndef assertEquals(x, y, epsilon=1e-8):\n    assert abs(x - y) &lt; epsilon\nThis is for testing a Square root function as \\(\\sqrt{n} * \\sqrt{n} = n\\). Since that is always true you don’t need a test case for different types of numbers. You should also check for invalid inputs so if someone tries to put a string into something that calculates squares that’s not going to work so your code should account for that in some way. Fuzzingbook has another good example of this\ndef sqrt_program(arg: str) -&gt; None:  # type: ignore\n    try:\n        x = float(arg)\n    except ValueError:\n        print(\"Illegal Input\")\n    else:\n        if x &lt; 0:\n            print(\"Illegal Number\")\n        else:\n            print('The root of', x, 'is', my_sqrt(x))\n\n\nOverall writing test cases and testing your code can be very beneficial not only for chasten but anything you do as it will make your code more polished and professional and easier to use for anyone trying to."
  },
  {
    "objectID": "FB.html#fb2-code-coverage",
    "href": "FB.html#fb2-code-coverage",
    "title": "Professional Précis Fuzzing Book",
    "section": "FB2 Code Coverage",
    "text": "FB2 Code Coverage\nCode Coverage is very important when writing test cases because you want to strive for as much of your code being tested as possible. So being able to check the effectiveness and coverage are crucial when writing good test cases. An example on how you can test this in the Fuzzing Book where there is a library with functions like .trace() and .coverage() which list what lines are in a given function and one returns what lines of code are at least run once. and using these libraries there was code that prints out code with the run lines marked by a # symbol\n\nUse-case\nThis can be very useful when working on chasten to test if the test cases being written and already there are doing their job properly. One of the last things you want is for you to test your code think it works but a significant portion of it is not being tested and maybe there is some major bug that is missed as a result. This is even more important when making software other people are going to use because then a lot more things can go wrong. After all, the code may need to adapt to different computers causing more issues that could be missed by testing."
  },
  {
    "objectID": "FB.html#fb3-fuzzing",
    "href": "FB.html#fb3-fuzzing",
    "title": "Professional Précis Fuzzing Book",
    "section": "FB3 Fuzzing",
    "text": "FB3 Fuzzing\nThe basic idea of fuzzing is to test as many possible reasonable inputs as possible so if you have a function that is supposed to receive a string. Then you can create a fuzzing generator that creates a string of random characters and with that and a runner to run the code you can test the limits of that specific function or program. This is a great way to test your code with unorthodox inputs and while they may be unlikely it can still help find. greater problems like let’s say you have a program that can only take a certain length of string before it crashes or if you’re doing something with math and a weird number or abnormally large number causes crashes or bugs. A fuzzer is a great way to help find these issues as so many different numbers and characters can be used by the code as inputs that having something to just check as many possibilities as possible can help improve the program’s efficiency and robustness.\n\nThe FuzzingBook has a great example of a basic fuzzer:\ndef fuzzer(max_length: int = 100, char_start: int = 32, char_range: int = 32) -&gt; str:\n    \"\"\"A string of up to `max_length` characters\n       in the range [`char_start`, `char_start` + `char_range`)\"\"\"\n    string_length = random.randrange(0, max_length + 1)\n    out = \"\"\n    for i in range(0, string_length):\n        out += chr(random.randrange(char_start, char_start + char_range))\n    return out\n\n\nUse-case\nThis can be a very useful concept for helping to uncover bugs as in my experience with chasten I’ve found a lot of bugs by just running the program with expected outputs. So, I can only imagine how many there are when there’s a lot of information it must sort through or when there’s an unexpected input which isn’t necessarily a bug, but it very well could be and the concept of something checking multiple different inputs and possibilities may help uncover many obscure bugs and issues."
  },
  {
    "objectID": "index.html#se4-knowledge-sharing",
    "href": "index.html#se4-knowledge-sharing",
    "title": "Professional Précis SE Book",
    "section": "SE4 Knowledge Sharing",
    "text": "SE4 Knowledge Sharing\nPeople in your organization or team should understand the problems of your software better than the internet. Often what happens is people withhold information so people will have a lot of information about a certain part but when they need to work with a different part of the program they don’t have the knowledge needed to work efficiently. This is not what you want you want everyone to be properly educated on the software they’re working on. This also causes people working in the same team to do things differently because they have different information which can cause conflicts and confusion slowing down the process of making a proper software program. Relating to the bus factor if one person has all the information on a subject and they get hit by a bus all the information is gone setting the project back significantly depending on what that person withheld then having to need people figure it out for themselves.\n\nUse-Case\nWith Chasten, a lot of people only have information on certain parts of the software and this causes problems when these people aren’t present as then we have no information on possibly a major part of the program leaving everyone I guess what is going on. Some people barely know the basics of the program so they may be assigned to a task and making very little progress because they don’t have the information required and no one would know as it’s not communicated."
  },
  {
    "objectID": "FB.html#fb4-mutation-analysis",
    "href": "FB.html#fb4-mutation-analysis",
    "title": "Professional Précis Fuzzing Book",
    "section": "FB4 Mutation Analysis",
    "text": "FB4 Mutation Analysis\nMutation analysis is just giving a function improper input on purpose the idea being if it. can’t detect when an input is incorrect it won’t be able to detect a bug. So, you can make functions that. take a test case and change it in certain ways to see if the program notices the change and if it doesn’t. you can have a problem. But you need to be careful when analyzing the mutations as they may be functionally identical to the original meaning you haven’t found a real issue.\nAn example of what you want to avoid is provided by the fuzzing book while being a bit extreme circumstance.\ndef ineffective_test_2():\n    try:\n        execute_the_program_as_a_whole()\n    except:\n        pass\n    assert True\nWhile this technically runs the code and gets code coverage another important subject when it comes to testing but that only checks if the test case runs all the code not if it checks what it’s supposed to. The above test case always returns true because all it does is run the function and if the function doesn’t run it still just. returns true because when asserting it doesn’t compare it to anything.\n\nUse-case\nMutation analysis is important when testing as you need to make sure your code is thoroughly testing what you want and isn’t giving any false negatives or false positives as then there may be a bug or issue you don’t know about. While you don’t need to write a function to mutate it for you it’s good to maybe have test cases that purposely fail so that you know your code won’t take improper inputs and run not finding any issues."
  },
  {
    "objectID": "index.html#se5-engineering-for-equity",
    "href": "index.html#se5-engineering-for-equity",
    "title": "Professional Précis SE Book",
    "section": "SE5 Engineering for Equity",
    "text": "SE5 Engineering for Equity\nOften with Software engineering especially on a large scale as in something like Google, it is important to keep in mind the broad amount of people that will be using your product. You need to make sure you are aware of some cultural differences and are proactive about finding and discovering problems in your software that may not affect you directly. A good example is brought up in this chapter where a software engineer found that Google image search algorithms would have black people show up when searching gorilla which is very bad. This was a major oversight from Google and is a result of them not including enough data on underrepresented people and just didn’t think this could be an issue. It’s also important to realize not everyone who uses your software is an expert so it should be easy to use and understand or at least fairly intuitive. If it’s not then you objectively have a bad product that may be clunky to use and has unintended issues that may anger people or offend them.\n\nUse-Case\nI think within this class I think the idea of thinking about who is using your software is very important and expecting many different types of people to use it. And while there probably won’t be anything as serious as what happened with Google it’s still important to design software with other people in mind not just the ones making it."
  }
]